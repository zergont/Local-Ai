<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Local AI — Chat</title>
  <link rel="icon" href="/favicon.ico" sizes="any">
  <style>
    :root{--bg:#0f1115;--card:#171a21;--text:#e6e8ee;--muted:#a8b3cf;--acc:#4da3ff;--gap:0}
    html,body{height:100%}
    *,*::before,*::after{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--text);font:16px/1.5 system-ui,Segoe UI,Roboto,Arial;display:flex;flex-direction:column;min-height:100vh}
    header{padding:16px 20px;border-bottom:1px solid #232836;background:#0f1115;position:sticky;top:0;z-index:10}
    .wrap{max-width:980px;width:100%;margin:0 auto;padding:20px}
    .row{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
    .card{background:var(--card);border:1px solid #232836;border-radius:14px;padding:14px}
    main.wrap{flex:1 1 auto;display:flex;flex-direction:column;gap:var(--gap);min-height:0}
    .msgs{flex:1 1 auto;display:flex;flex-direction:column;gap:12px;overflow:auto;padding:8px;border-radius:12px;align-items:stretch;width:100%;min-height:0}
    .msg{padding:12px;border-radius:12px;max-width:100%;width:100%;overflow-wrap:anywhere;word-break:break-word}
    .u{background:#1e2430}
    .a{background:#131722}
    .meta{color:var(--muted);font-size:12px;margin-top:6px}
    button,input,textarea{font:inherit}
    textarea{width:100%;min-height:100px;resize:vertical;background:#0f1115;color:var(--text);border:1px solid #232836;border-radius:12px;padding:10px}
    .controls{display:flex;gap:8px;align-items:center;margin-top:8px;flex-wrap:wrap}
    .controls button{background:var(--acc);border:none;color:#081120;padding:10px 14px;border-radius:10px;cursor:pointer}
    .controls input[type=file]{display:none}
    .pill{color:var(--muted);font-size:12px}
    a{color:#8ecbff}
    .kbd{font:12px/1 monospace;background:#0b0d12;border:1px solid #232836;border-radius:6px;padding:2px 6px}
    details{background:#0f141d;border:1px solid #232836;border-radius:8px;padding:6px 10px;margin-top:6px}
    details pre{white-space:pre-wrap;font:12px/1.4 monospace;margin:6px 0 0;padding:6px;background:#0b0f15;border:1px solid #232836;border-radius:6px;max-height:320px;overflow:auto}
    details.think-spoiler[data-streaming="true"] summary::after{content:" (обновляется...)";color:var(--muted);font-size:11px}
    details.think-spoiler summary{cursor:pointer;user-select:none}
    details.think-spoiler summary:hover{color:var(--acc)}
    label.checkbox{display:flex;align-items:center;gap:4px;font-size:12px;color:var(--muted);cursor:pointer}
    .composer{position:sticky;bottom:0;z-index:5;background:var(--bg);border-top:1px solid #232836;padding-top:12px}
    /* LLM status dot */
    .dot{width:10px;height:10px;border-radius:50%;display:inline-block;border:1px solid #2a2f3a}
    .dot.ok{background:#28c76f;border-color:#1e4b34}
    .dot.bad{background:#ff4d4f;border-color:#5a1f22}
  </style>
</head>
<body>
<header class="wrap">
  <div class="row">
    <strong>Local AI — Chat</strong>
    <span class="pill" id="thread-pill"></span>
    <span class="pill">Ctrl/⌘+Enter — отправить</span>
    <label class="checkbox"><input type="checkbox" id="toggle-think"/> Показывать рассуждения</label>
    <span class="pill">LLM: <span id="llm-dot" class="dot bad" title="Соединение с LLM"></span></span>
  </div>
</header>
<main class="wrap">
  <div id="messages" class="msgs"></div>

  <div class="composer">
    <div class="card">
      <textarea id="input" placeholder="Напишите сообщение..."></textarea>
      <div class="controls">
        <label for="file"><span class="kbd">+</span> Вложение</label>
        <input id="file" type="file" />
        <button id="send">Отправить</button>
        <button id="new">Новый диалог</button>
        <span id="status" class="pill"></span>
      </div>
    </div>
  </div>
</main>

<script>
const api = (path) => path.startsWith('http') ? path : (location.origin + path);
let threadId = localStorage.getItem('thread_id') || null;
let useWS = true;
let CFG = { MODEL_CONTROLLER: '', CONTEXT_WINDOW_TOKENS: 0, CONTEXT_PROMPT_BUDGET_RATIO: 0 };

const elMsgs = document.getElementById('messages');
const elInput = document.getElementById('input');
const elSend = document.getElementById('send');
const elFile = document.getElementById('file');
const elNew = document.getElementById('new');
const elStatus = document.getElementById('status');
const elPill = document.getElementById('thread-pill');
const elThink = document.getElementById('toggle-think');
const elLlmDot = document.getElementById('llm-dot');

// Helpers to remove leading blank lines (start of message and right after </think>)
function normalizeStart(text){
  return String(text || '').replace(/^(?:[ \t]*\r?\n)+/, '');
}
function trimLeadingBlank(s){
  return String(s || '').replace(/^(?:[ \t]*\r?\n)+/, '');
}

let autoScroll = true;
function scrollToBottom(){ elMsgs.scrollTo({ top: elMsgs.scrollHeight, behavior: 'auto' }); }
function keepScrolled(){ if(autoScroll){ scrollToBottom(); } }
function isNearBottom(){ return (elMsgs.scrollHeight - elMsgs.scrollTop - elMsgs.clientHeight) < 120; }
elMsgs.addEventListener('scroll', ()=>{ autoScroll = isNearBottom(); });

function setThread(id){
  threadId = id;
  if(id){ localStorage.setItem('thread_id', id); elPill.textContent = 'thread: ' + id.slice(0,8) + '…'; }
  else { localStorage.removeItem('thread_id'); elPill.textContent = 'новый тред'; }
}
setThread(threadId);

function addMsg(role, html){
  const div = document.createElement('div');
  div.className = 'msg ' + (role === 'user' ? 'u' : 'a');
  
  if (role === 'assistant') {
    const norm = normalizeStart((html || '').replace(/<br>/g, '\n'));
    div.setAttribute('data-original', norm);
    const processedText = processThinkTags(norm);
    div.innerHTML = processedText.replace(/\n/g, '<br>');
  } else {
    div.textContent = html;
  }
  
  elMsgs.appendChild(div);
  layout();
  keepScrolled();
}

function escapeHtml(s){ return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/\"/g,'&quot;').replace(/'/g,'&#39;'); }

function wrapThinkSpoiler(inner, isStreaming = false, spoilerIndex = 0){
  inner = String(inner).trim(); 
  if(!inner) return '';
  const detailsId = `think-${spoilerIndex}`;
  const openAttr = isStreaming ? ' open' : '';
  return `<details class="think-spoiler" ${isStreaming ? 'data-streaming=\"true\"' : ''} id="${detailsId}"${openAttr}><summary>Рассуждения</summary>\n<pre data-content="${escapeHtml(inner)}">${escapeHtml(inner)}</pre></details>\n`;
}

function processThinkTags(text){
  const showThink = elThink && elThink.checked;
  const src = String(text || '');
  let out = '';
  let last = 0;
  let sawThink = false;
  const re = /<think>([\s\S]*?)<\/think>/gi;
  let m; let idx = 0;
  while((m = re.exec(src)) !== null){
    const before = src.slice(last, m.index);
    out += escapeHtml(before);
    if (showThink){
      out += wrapThinkSpoiler(m[1], false, idx);
      idx++; sawThink = true;
    }
    last = re.lastIndex;
  }
  let tail = src.slice(last);
  if (sawThink) tail = trimLeadingBlank(tail); // remove blank lines right after </think>
  out += escapeHtml(tail);
  return out;
}

function processStreamingThink(rawText) {
  const showThink = elThink && elThink.checked;
  let src = normalizeStart(String(rawText || ''));
  const openPos = src.lastIndexOf('<think>');
  const closePos = src.lastIndexOf('</think>');
  if (openPos !== -1 && (closePos === -1 || closePos < openPos)) {
    const beforeThink = src.substring(0, openPos);
    const insideThink = src.substring(openPos + 7);
    if (!showThink) {
      return escapeHtml(beforeThink);
    } else {
      const completedThinks = (beforeThink.match(/<\/think>/gi) || []).length;
      return processThinkTags(beforeThink) + wrapThinkSpoiler(insideThink, true, completedThinks);
    }
  } else {
    return processThinkTags(src);
  }
}

let openedSpoilers = new Set();
function saveOpenSpoilers(element) {
  const spoilers = element.querySelectorAll('details.think-spoiler');
  spoilers.forEach(spoiler => {
    if (spoiler.open && spoiler.id) openedSpoilers.add(spoiler.id);
    else if (!spoiler.open && spoiler.id) openedSpoilers.delete(spoiler.id);
  });
}
function restoreOpenSpoilers(element) {
  const spoilers = element.querySelectorAll('details.think-spoiler');
  spoilers.forEach(spoiler => {
    if (spoiler.id && openedSpoilers.has(spoiler.id)) spoiler.open = true;
  });
}

function updateMessageWithSpoilerState(element, rawText) {
  saveOpenSpoilers(element);
  const processedText = processStreamingThink(normalizeStart(rawText));
  element.innerHTML = processedText.replace(/\n/g, '<br>');
  restoreOpenSpoilers(element);
  const spoilers = element.querySelectorAll('details.think-spoiler');
  spoilers.forEach(spoiler => {
    spoiler.addEventListener('toggle', () => {
      if (!spoiler.id) return;
      if (spoiler.open) openedSpoilers.add(spoiler.id);
      else openedSpoilers.delete(spoiler.id);
    });
  });
}

async function loadConfig(){
  try{ const res = await fetch(api('/config')); const cfg = await res.json(); CFG = cfg; setLlmDot(!!cfg.LLM_ONLINE); }catch{ setLlmDot(false); }
}

function setLlmDot(ok){
  if(!elLlmDot) return;
  elLlmDot.classList.remove('ok','bad');
  elLlmDot.classList.add(ok ? 'ok' : 'bad');
}

async function pollHealth(){
  try{
    const r = await fetch(api('/health'));
    if(!r.ok) throw new Error('bad');
    const j = await r.json();
    setLlmDot(!!j.llm_online);
  }catch{ setLlmDot(false); }
}

function budgetStr(){
  const b = Math.floor((CFG.CONTEXT_WINDOW_TOKENS||0) * (CFG.CONTEXT_PROMPT_BUDGET_RATIO||0));
  return b ? ` | budget≈ ${b}` : '';
}

elThink.addEventListener('change', ()=>{
  const mode = elThink.checked ? 'show' : 'hide';
  localStorage.setItem('think_mode', mode);
  const assistantMsgs = document.querySelectorAll('.msg.a');
  assistantMsgs.forEach(msgEl => {
    const openIds = Array.from(msgEl.querySelectorAll('details.think-spoiler'))
      .filter(d => d.open && d.id)
      .map(d => d.id);
    const originalHtml = msgEl.getAttribute('data-original');
    if (originalHtml) {
      const processedText = processThinkTags(normalizeStart(originalHtml.replace(/<br>/g, '\n')));
      msgEl.innerHTML = processedText.replace(/\n/g, '<br>');
      openIds.forEach(id => {
        const d = msgEl.querySelector(`#${CSS.escape(id)}`);
        if (d) d.open = true;
      });
    }
  });
});

async function uploadFile(file){
  const fd = new FormData(); fd.append('file', file);
  const res = await fetch(api('/ui/upload'), { method:'POST', body: fd });
  if(!res.ok){ if(res.status === 413) throw new Error('Файл слишком большой'); const text = await res.text(); throw new Error(text || 'Ошибка загрузки'); }
  return res.json();
}

elFile.addEventListener('change', async (e)=>{
  const f = e.target.files?.[0]; if(!f) return; elStatus.textContent = 'Загрузка файла…';
  try{ const j = await uploadFile(f); elInput.value = (elInput.value ? elInput.value + '\n' : '') + j.url; elStatus.textContent = 'Файл готов: ' + j.url; }
  catch(err){ elStatus.textContent = err.message || 'Ошибка загрузки'; }
  finally{ elFile.value = ''; }
});

async function sendWS(){
  const text = elInput.value.trim(); if(!text) return;
  addMsg('user', text);
  elInput.value=''; elStatus.textContent='Стрим…';
  const ws = new WebSocket((location.protocol === 'https:' ? 'wss://' : 'ws://') + location.host + '/ws/respond');
  ws.onopen = () => { const payload = { input_text: text, store: true }; if(threadId) payload.thread_id = threadId; ws.send(JSON.stringify(payload)); };
  let accRaw=''; let firstAssistShown=false;
  ws.onmessage = (ev)=>{
    const msg = JSON.parse(ev.data);
    if(msg.type==='start'){
      if(!threadId && msg.thread_id) setThread(msg.thread_id);
    }else if(msg.type==='delta'){
      accRaw += msg.text;
      
      if(!firstAssistShown){ 
        const div = document.createElement('div');
        div.className = 'msg a';
        div.setAttribute('data-original', normalizeStart(accRaw).replace(/\n/g,'<br>'));
        updateMessageWithSpoilerState(div, accRaw);
        elMsgs.appendChild(div);
        layout();
        keepScrolled();
        firstAssistShown=true; 
      } else { 
        const lastMsg = elMsgs.lastChild;
        lastMsg.setAttribute('data-original', normalizeStart(accRaw).replace(/\n/g,'<br>'));
        updateMessageWithSpoilerState(lastMsg, accRaw);
        keepScrolled(); 
      }
    }else if(msg.type==='end'){
      const budget = budgetStr();
      elStatus.textContent = (msg.usage ? `tokens≈ ${msg.usage.total_tokens}` : '') + ` | model=${(CFG.MODEL_CONTROLLER||'')}${budget}`;
      ws.close();
    }else if(msg.type==='error'){
      addMsg('assistant','⚠️ Ошибка: '+(msg.message||'internal'));
      elStatus.textContent='Ошибка'; ws.close();
    }
  };
  ws.onerror = ()=>{ addMsg('assistant','⚠️ WS error'); elStatus.textContent='Ошибка'; };
}

async function sendPOST(){
  const text = elInput.value.trim(); if(!text) return;
  addMsg('user', text);
  elInput.value=''; elStatus.textContent='Думаю…';
  const payload = { input_text: text, store: true }; if(threadId) payload.thread_id = threadId;
  try{
    const res = await fetch(api('/responses'), { method:'POST', headers:{ 'Content-Type':'application/json' }, body: JSON.stringify(payload) });
    const j = await res.json(); if(!res.ok) throw new Error((j && j.detail) || 'error');
    if(!threadId && j.thread_id) setThread(j.thread_id);
    const responseText = normalizeStart(j.output_text || '(пусто)');
    addMsg('assistant', responseText);
    const budget = budgetStr();
    elStatus.textContent = (j.usage ? `tokens≈ ${j.usage.total_tokens}` : '') + ` | model=${(CFG.MODEL_CONTROLLER||'')}${budget}`;
  }catch(err){
    addMsg('assistant','⚠️ Ошибка: '+err.message);
    elStatus.textContent='Ошибка';
  }
}

function send(){ if(useWS && 'WebSocket' in window){ sendWS(); } else { sendPOST(); } }

function layout(){
  const header = document.querySelector('header');
  const comp = document.querySelector('.composer');
  const headerH = header ? header.getBoundingClientRect().height : 0;
  const compH = comp ? comp.getBoundingClientRect().height : 0;
  const wrapPaddingV = 40;
  const h = Math.max(160, window.innerHeight - headerH - compH - wrapPaddingV);
  elMsgs.style.height = h + 'px';
  elMsgs.style.paddingBottom = '0px';
}

document.addEventListener('DOMContentLoaded', ()=>{ 
  layout(); 
  keepScrolled(); 
  const saved = localStorage.getItem('think_mode');
  elThink.checked = (saved === 'show');
  loadConfig();
  pollHealth();
  setInterval(pollHealth, 5000);
});

window.addEventListener('resize', layout);
new ResizeObserver(layout).observe(document.querySelector('.composer'));

elSend.addEventListener('click', send);
elInput.addEventListener('keydown', (e)=>{ if((e.metaKey||e.ctrlKey) && e.key==='Enter'){ send(); } });
elNew.addEventListener('click', ()=>{ setThread(null); addMsg('assistant','— Новый диалог —'); });

</script>
</body>
</html>
