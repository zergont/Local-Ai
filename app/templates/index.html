<!doctype html>
<html lang="ру">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Local AI — Chat</title>
  <style>
    :root{--bg:#0f1115;--card:#171a21;--text:#e6e8ee;--muted:#a8b3cf;--acc:#4da3ff;}
    *{box-sizing:border-box}
    *::before,*::after{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--text);font:16px/1.5 system-ui,Segoe UI,Roboto,Arial}
    header{padding:16px 20px;border-bottom:1px solid #232836;background:#0f1115;position:sticky;top:0;z-index:100}
    .wrap{max-width:980px;margin:0 auto;padding:20px}
    .row{display:flex;gap:12px;align-items:center}
    .card{background:var(--card);border:1px solid #232836;border-radius:14px;padding:14px}
    .msgs{display:flex;flex-direction:column;gap:12px;padding-bottom:24px}
    .msg{padding:12px;border-radius:12px}
    .u{background:#1e2430}
    .a{background:#131722}
    .meta{color:var(--muted);font-size:12px;margin-top:6px}
    button,input,textarea{font:inherit}
    textarea{width:100%;min-height:80px;resize:vertical;background:#0f1115;color:var(--text);border:1px solid #232836;border-radius:12px;padding:10px}
    .controls{display:flex;gap:8px;align-items:center;margin-top:8px;flex-wrap:wrap}
    .controls button{background:var(--acc);border:none;color:#081120;padding:10px 14px;border-radius:10px;cursor:pointer}
    .controls input[type=file]{display:none}
    .pill{color:var(--muted);font-size:12px}
    a{color:#8ecbff}
    .kbd{font:12px/1 monospace;background:#0b0d12;border:1px solid #232836;border-radius:6px;padding:2px 6px}

    /* Размышления под спойлером */
    details.reasoning{background:#0b0d12;border:1px solid #232836;border-radius:10px;padding:8px;margin:8px 0}
    details.reasoning > summary.reasoning-header{color:var(--muted);font-size:12px;cursor:pointer;user-select:none;outline:none}
    details.reasoning > .reasoning-body{margin-top:6px;max-height:240px;overflow:auto;white-space:pre-wrap;font:13px/1.5 ui-monospace,SFMono-Regular,Menlo,Consolas,"Liberation Mono",monospace}
    details.reasoning > summary::-webkit-details-marker{color:var(--muted)}

    /* Композер закреплён внизу */
    .composer{position:sticky;bottom:0;z-index:90;margin-top:8px}
  </style>
</head>
<body>
<header class="wrap">
  <div class="row">
    <strong>Local AI — Chat</strong>
    <span class="pill" id="thread-pill"></span>
    <span class="pill">Ctrl/⌘+Enter — отправить</span>
  </div>
</header>
<main class="wrap">
  <div id="messages" class="msgs"></div>

  <div class="card composer">
    <textarea id="input" placeholder="Напишите сообщение..."></textarea>
    <div class="controls">
      <label for="file"><span class="kbd">+</span> Вложение</label>
      <input id="file" type="file" />
      <button id="send">Отправить</button>
      <button id="new">Новый диалог</button>
      <span id="status" class="pill"></span>
    </div>
  </div>
</main>

<script>
const api = (path) => path.startsWith('http') ? path : (location.origin + path);
let threadId = localStorage.getItem('thread_id') || null;
let useWS = true;

const elMsgs = document.getElementById('messages');
const elInput = document.getElementById('input');
const elSend = document.getElementById('send');
const elFile = document.getElementById('file');
const elNew = document.getElementById('new');
const elStatus = document.getElementById('status');
const elPill = document.getElementById('thread-pill');

function scrollToBottom(){
  try{ window.scrollTo({ top: document.documentElement.scrollHeight, behavior: 'auto' }); }
  catch(_){ window.scrollTo(0, document.documentElement.scrollHeight); }
}

function setThread(id){
  threadId = id;
  if(id){ localStorage.setItem('thread_id', id); elPill.textContent = 'thread: ' + id.slice(0,8) + '…'; }
  else { localStorage.removeItem('thread_id'); elPill.textContent = 'новый тред'; }
}
setThread(threadId);

function escapeHtml(s){ return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

function addMsg(role, text){
  const div = document.createElement('div');
  div.className = 'msg ' + (role === 'user' ? 'u' : 'a');
  div.innerHTML = escapeHtml(text).replace(/\n/g,'<br>');
  elMsgs.appendChild(div);
  scrollToBottom();
}

async function uploadFile(file){
  const fd = new FormData();
  fd.append('file', file);
  const res = await fetch(api('/ui/upload'), { method:'POST', body: fd });
  if(!res.ok){
    if(res.status === 413) throw new Error('Файл слишком большой');
    const text = await res.text();
    throw new Error(text || 'Ошибка загрузки');
  }
  return res.json();
}

elFile.addEventListener('change', async (e)=>{
  const f = e.target.files?.[0];
  if(!f) return;
  elStatus.textContent = 'Загрузка файла…';
  try{
    const j = await uploadFile(f);
    elInput.value = (elInput.value ? elInput.value + '\n' : '') + j.url;
    elStatus.textContent = 'Файл готов: ' + j.url;
  }catch(err){
    elStatus.textContent = err.message || 'Ошибка загрузки';
  }finally{
    elFile.value = '';
  }
});

function createAssistantNode(){
  const div = document.createElement('div');
  div.className = 'msg a';
  const rs = document.createElement('details');
  rs.className = 'reasoning';
  rs.style.display = 'none'; // показываем только когда начнутся размышления
  const rsHead = document.createElement('summary');
  rsHead.className = 'reasoning-header';
  rsHead.textContent = 'Размышления';
  const rsBody = document.createElement('div');
  rsBody.className = 'reasoning-body';
  rs.appendChild(rsHead);
  rs.appendChild(rsBody);
  const body = document.createElement('div');
  body.className = 'assistant-body';
  div.appendChild(rs);
  div.appendChild(body);
  elMsgs.appendChild(div);
  scrollToBottom();
  return { container: div, body, rs, rsBody };
}

async function sendWS(){
  const text = elInput.value.trim();
  if(!text) return;
  addMsg('user', text);
  elInput.value = '';
  elStatus.textContent = 'Стрим…';

  const ws = new WebSocket((location.protocol === 'https:' ? 'wss://' : 'ws://') + location.host + '/ws/respond');
  let ui = null;
  let inThink = false;
  let pending = '';
  let answerText = '';
  let reasoningText = '';

  const openTagRe = /<(think|reasoning|thinking)\b[^>]*>/i;
  const closeTagRe = /<\/\s*(think|reasoning|thinking)\s*>/i;

  function updateUI(){
    if(!ui) ui = createAssistantNode();
    ui.body.innerHTML = escapeHtml(answerText).replace(/\n/g,'<br>');
    // Показываем спойлер, если уже идёт think или накоплен текст размышлений
    if(reasoningText || inThink){
      ui.rs.style.display = '';
      ui.rsBody.textContent = reasoningText;
    } else {
      ui.rs.style.display = 'none';
    }
    scrollToBottom();
  }

  function processPending(final=false){
    while(pending.length > 0){
      if(!inThink){
        const m = pending.match(openTagRe);
        if(m){
          const i = m.index;
          answerText += pending.slice(0, i);
          pending = pending.slice(i + m[0].length);
          inThink = true;
          updateUI();
        } else {
          if(final){
            answerText += pending;
            pending = '';
            updateUI();
            break;
          }
          const keep = Math.min(pending.length, 8);
          const flushLen = pending.length - keep;
          if(flushLen > 0){
            answerText += pending.slice(0, flushLen);
            pending = pending.slice(flushLen);
            updateUI();
          } else {
            break;
          }
        }
      } else {
        const m = pending.match(closeTagRe);
        if(m){
          const i = m.index;
          reasoningText += pending.slice(0, i);
          pending = pending.slice(i + m[0].length);
          inThink = false;
          updateUI();
        } else {
          if(final){
            reasoningText += pending;
            pending = '';
            updateUI();
            break;
          }
          const keep = Math.min(pending.length, 8);
          const flushLen = pending.length - keep;
          if(flushLen > 0){
            reasoningText += pending.slice(0, flushLen);
            pending = pending.slice(flushLen);
            updateUI();
          } else {
            break;
          }
        }
      }
    }
  }

  ws.onopen = () => {
    const payload = { input_text: text, store: true };
    if(threadId) payload.thread_id = threadId;
    ws.send(JSON.stringify(payload));
  };

  ws.onmessage = (ev) => {
    const msg = JSON.parse(ev.data);
    if(msg.type === 'start'){
      if(!threadId && msg.thread_id) setThread(msg.thread_id);
      if(!ui) ui = createAssistantNode();
    }else if(msg.type === 'delta'){
      pending += msg.text;
      processPending(false);
    }else if(msg.type === 'end'){
      pending += '';
      processPending(true); // финальная обработка — слить остатки
      updateUI();
      elStatus.textContent = msg.usage ? `tokens≈ ${msg.usage.total_tokens}` : '';
      ws.close();
    }else if(msg.type === 'error'){
      addMsg('assistant', '⚠️ Ошибка: ' + (msg.message || 'internal'));
      elStatus.textContent = 'Ошибка';
      ws.close();
    }
  };
  ws.onerror = () => { addMsg('assistant','⚠️ WS error'); elStatus.textContent = 'Ошибка'; };
}

async function sendPOST(){
  const text = elInput.value.trim();
  if(!text) return;
  addMsg('user', text);
  elInput.value = '';
  elStatus.textContent = 'Думаю…';

  const payload = { input_text: text, store: true };
  if(threadId) payload.thread_id = threadId;

  try{
    const res = await fetch(api('/responses'), {
      method:'POST',
      headers:{ 'Content-Type':'application/json' },
      body: JSON.stringify(payload)
    });
    const j = await res.json();
    if(!res.ok){ throw new Error((j && j.detail) || 'error'); }

    if(!threadId && j.thread_id) setThread(j.thread_id);
    addMsg('assistant', j.output_text || '(пусто)');
    elStatus.textContent = j.usage ? `tokens≈ ${j.usage.total_tokens}` : '';
  }catch(err){
    addMsg('assistant', '⚠️ Ошибка: ' + err.message);
    elStatus.textContent = 'Ошибка';
  }
}

function send(){
  if(useWS && 'WebSocket' in window){ sendWS(); }
  else { sendPOST(); }
}

elSend.addEventListener('click', send);
elInput.addEventListener('keydown', (e)=>{ if((e.metaKey || e.ctrlKey) && e.key === 'Enter'){ send(); } });

elNew.addEventListener('click', ()=>{ setThread(null); addMsg('assistant', '— Новый диалог —'); });
</script>
</body>
</html>
